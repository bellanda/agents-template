---
description: "[Agents Template] Frontend - stack, chat UI, agents dashboard, AI Elements, Streamdown markdown"
globs: frontend/**/*.{ts,tsx}
alwaysApply: false
---

# Agents Template – Frontend (chat, dashboard, AI Elements)

Rules for the **agents-template** frontend: stack, chat UI, sidebar/dashboard for agents, AI Elements, Streamdown. Use only when working on frontend in a project that uses this template.

## ⚠️ Production Warnings

**This template uses development defaults that MUST be adapted for production:**

1. **User Authentication**: Default user is `"default_user"` via `useUserId()` hook:
   - **Location**: `src/hooks/useUserId.ts`
   - **Replace**: Integrate with your auth system (JWT, session, OAuth, etc.)
   - **Example**: See hook comments for integration pattern
   - **Backend**: Ensure `ChatRequest.user` is populated from your auth middleware

2. **API Endpoints**: Template assumes backend at `localhost:8000`:
   - **Vite proxy**: `/api` → `localhost:8000` (see `vite.config.ts`)
   - **Production**: Update proxy or use absolute URLs
   - **CORS**: Ensure backend CORS allows your frontend origin

3. **Database**: Frontend assumes SQLite backend (see backend rules):
   - Threads API filters by `user_id` from backend
   - History hydration depends on backend thread storage
   - Adapt if backend uses different database

---

## Stack

- **Runtime:** Bun only (`bun dev`, `bun add`, `bun install`)
- **UI:** Shadcn/ui + Tailwind v4
- **Routing:** TanStack Router (file-based, SPA mode)
- **AI:** `@ai-sdk/react` (useChat) + `ai` (DefaultChatTransport)
- **Icons:** @phosphor-icons/react, lucide-react
- **Paths:** `@/` → `src/` (configured in `tsconfig.json` and `vite.config.ts`)
- **Vite proxy:** `/api` → `localhost:8000` (development)

---

## AI Elements (Vercel) – Doc Links

- **Message** (display, branching, actions, markdown): https://elements.ai-sdk.dev/components/message  
- **Conversation** (scroll, empty state, download): https://elements.ai-sdk.dev/components/conversation  
- **Reasoning** (collapsible thinking, streaming): https://elements.ai-sdk.dev/components/reasoning  
- **Chain of Thought** (step-by-step): https://elements.ai-sdk.dev/components/chain-of-thought  

**Installation:**
```bash
bunx ai-elements@latest add message conversation reasoning
```

Then use from `@/components/ai-elements/...` (auto-generated during install).

---

## Markdown: Streamdown (required for MessageResponse / rich markdown)

**In `src/styles.css` (required):**

```css
@source "../node_modules/streamdown/dist/*.js";

/* Markdown links should show pointer cursor */
.prose a,
[class*="prose"] a {
  cursor: pointer;
}
```

**Usage in components:**

Use the **Streamdown** component for assistant text (GFM, code highlight, math, incomplete markdown). Do **not** use a custom regex-based renderer.

```tsx
import { Streamdown } from "streamdown";

// In message parts loop, for part.type === "text"
<Streamdown
  key={`${message.id}-${i}`}
  className="prose prose-sm dark:prose-invert max-w-none wrap-break-word [&_a]:cursor-pointer [&_pre]:overflow-x-auto [&_pre]:max-w-full [&_code]:break-all"
  parseIncompleteMarkdown
>
  {textContent}
</Streamdown>
```

**Important:** The CSS rule `.prose a { cursor: pointer; }` ensures links rendered from markdown show a pointer cursor on hover. This is required for proper UX.

**Alternative:** If using AI Elements, use **MessageResponse** for text (it uses Streamdown internally):
```tsx
<MessageResponse>{part.text}</MessageResponse>
```

---

## useChat (AI SDK 5.0+)

**Setup:**

```tsx
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { useUserId } from "@/hooks/useUserId";

const [userId] = useUserId();
const { messages, sendMessage, setMessages, status, stop } = useChat({
  id: sessionId,  // Thread ID for chat mode
  transport: new DefaultChatTransport({
    api: "/api/v1/agents/chat/completions",
    body: {
      model: agentId,  // Agent model_id
      stream: true,  // Always true for streaming
      user: userId,  // Required for user-scoped thread filtering
      ...(sessionId ? { session_id: sessionId } : {}),
    },
  }),
});

sendMessage({ text: input });  // NOT { role, content }
const isStreaming = status === "submitted" || status === "streaming";
```

**Key points:**
- `id`: Session/thread ID for chat mode (undefined for single-shot)
- `user`: User ID from `useUserId()` hook (required for backend filtering)
- `session_id`: Optional, passed in body if provided
- `sendMessage({ text })`: AI SDK format, not OpenAI format
- `status`: `"idle"`, `"submitted"`, `"streaming"`, `"error"`

**User ID Hook:**
- `useUserId()` returns `["default_user", () => {}]` by default
- **Production**: Replace with your auth system
- Hook is designed to be easily pluggable (see `src/hooks/useUserId.ts`)

---

## Message Parts (reasoning + text)

**Sorting and rendering:**

```tsx
const sortedParts = [...(message.parts ?? [])].sort((a, b) => {
  const order: Record<string, number> = { reasoning: 0, text: 1 };
  return (order[a?.type] ?? 2) - (order[b?.type] ?? 2);
});

sortedParts.map((part, i) => {
  if (!part || typeof part !== "object") return null;
  const textContent = "text" in part ? String((part as { text?: string }).text ?? "") : "";
  
  switch (part.type) {
    case "reasoning":
      // Only show reasoning during live streaming
      if (isStreaming && isLastMessage) {
        return (
          <Reasoning key={`${message.id}-reasoning-${i}`} isStreaming={true}>
            <ReasoningTrigger />
            <ReasoningContent>{textContent}</ReasoningContent>
          </Reasoning>
        );
      }
      return null;  // Hide reasoning after streaming completes
      
    case "text":
      return (
        <MessageResponse key={`${message.id}-text-${i}`}>
          {textContent}
        </MessageResponse>
      );
      
    default:
      return null;
  }
});
```

**Reasoning display:**
- Only shown during live streaming (`isStreaming && isLastMessage`)
- Hidden after streaming completes (to reduce UI clutter)
- Uses AI Elements `Reasoning` component (collapsible)

**Text display:**
- Uses `MessageResponse` (AI Elements) or `Streamdown` directly
- Supports incomplete markdown during streaming
- Handles code blocks, math, links, etc.

---

## Chat vs Single-Shot

### Chat Mode (`/chat/$agentId`)

**Features:**
- Persistent conversation history (saved per user)
- Session ID from URL search params: `?session=thread_123`
- History hydration on mount (fetches from `/threads/{id}`)
- Sidebar shows conversation history
- `key={sessionId}` on ChatView to remount on session change

**Implementation:**
```tsx
// Route: src/routes/chat/$agentId.tsx
const { session } = Route.useSearch();
const sessionId = session || `thread_${Date.now()}`;

<ChatView 
  agentId={agentId} 
  sessionId={sessionId} 
  singleShot={false} 
  key={sessionId}  // Remount on session change
/>
```

**History hydration:**
```tsx
useEffect(() => {
  if (sessionId && !singleShot) {
    fetch(`/api/v1/agents/threads/${sessionId}`)
      .then(res => res.json())
      .then(data => {
        const hydrated = data.messages.map((msg: any) => ({
          id: msg.id || `${msg.role}-${Date.now()}`,
          role: msg.role,
          parts: [{ type: "text", text: msg.content }],
        }));
        setMessages(hydrated);
      });
  }
}, [sessionId, singleShot]);
```

### Single-Shot Mode (`/agent/$agentId`)

**Features:**
- No history saved
- Each request is independent
- Call `setMessages([])` before each `sendMessage`
- No session ID needed

**Implementation:**
```tsx
// Route: src/routes/agent/$agentId.tsx
<ChatView 
  agentId={agentId} 
  sessionId={undefined} 
  singleShot={true} 
/>

// In ChatView, before sending:
if (singleShot) {
  setMessages([]);  // Clear previous messages
}
sendMessage({ text: input });
```

---

## Routes & Layouts (agents-template dashboard)

**Layout Pattern:** All routes use layout components from `@/components/layouts`:

```tsx
import { SidebarLayout } from "@/components/layouts";
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/chat/$agentId")({
  component: ChatPage
});

function ChatPage() {
  const { agentId } = Route.useParams();
  const { session } = Route.useSearch();
  
  return (
    <SidebarLayout>
      <ChatView 
        agentId={agentId} 
        sessionId={session} 
        singleShot={false} 
      />
    </SidebarLayout>
  );
}
```

**Route structure:**
- `__root.tsx`: ThemeProvider wrapper only. Layouts are applied per-route.
- `index.tsx`: Home page wrapped in `SidebarLayout`.
- `chat/$agentId.tsx`: ChatView with sessionId, wrapped in `SidebarLayout`.
- `agent/$agentId.tsx`: ChatView singleShot, wrapped in `SidebarLayout`.

**Layout Components:**
- `SidebarLayout`: Provides sidebar navigation, header with theme toggle, and main content area.
- Located in `src/components/layouts/sidebar-layout.tsx`.
- Sidebar component in `src/components/sidebar/app-sidebar.tsx`.

---

## Sidebar (Chat History)

**Component:** `AppSidebar` (`src/components/sidebar/app-sidebar.tsx`)

**Features:**
- Displays conversation history grouped by date:
  - Today
  - Yesterday
  - Previous 7 days
  - Older
- Shows all threads for the current user (filtered by `user_id`)
- "New Chat" button at the top to start a new conversation
- Click on a thread to navigate to that conversation
- Delete button (trash icon) appears on hover
- Thread titles are truncated with ellipsis (`...`) when they exceed available width
- Sidebar has fixed width of `16rem` (256px)

**Thread fetching:**
```tsx
const [userId] = useUserId();
const fetchThreads = async () => {
  const res = await fetch(`/api/v1/agents/threads?user_id=${userId}`);
  const data = await res.json();
  setThreads(data.threads);
};
```

**Thread deletion:**
```tsx
const deleteThread = async (threadId: string) => {
  await fetch(`/api/v1/agents/threads/${threadId}`, { method: "DELETE" });
  window.dispatchEvent(new CustomEvent("agents:threads:updated"));
  // Navigate away if current thread was deleted
};
```

**Event system:**
- `agents:threads:updated` event dispatched after thread operations
- Sidebar listens and refetches threads
- ChatView dispatches after message completion

**Note:** Sidebar shows chat history, not agent list. Agents are selected via ModelSelector in the chat input footer.

**Layout Integration:** The sidebar is integrated via `SidebarLayout` component, which provides the `SidebarProvider`, `SidebarInset`, header with theme toggle, and main content area.

---

## Agent Selector & Suggestions

### ModelSelector

**Location:** Chat input footer (below textarea)

**Features:**
- Dropdown to switch between chat-mode agents
- Positioned like Vercel AI Elements example
- Only shows agents with `mode: "chat"` (single-shot agents excluded)
- Fetches agents from `/api/v1/agents` endpoint

**Implementation:**
```tsx
const [agents, setAgents] = useState<Agent[]>([]);

useEffect(() => {
  fetch("/api/v1/agents")
    .then(res => res.json())
    .then(data => {
      const chatAgents = data.data.filter((a: Agent) => a.mode === "chat");
      setAgents(chatAgents);
    });
}, []);

<ModelSelector
  agents={agents}
  value={agentId}
  onValueChange={(id) => navigate({ to: `/chat/${id}`, search: { session } })}
/>
```

### Suggestions

**Display:** Shown when chat is empty (no messages)

**Source:** `agent.suggestions` from backend (from `AGENT_SUGGESTIONS` in `agent.py`)

**Implementation:**
```tsx
const suggestions = agents.find(a => a.id === agentId)?.suggestions || [];

{messages.length === 0 && suggestions.length > 0 && (
  <div className="suggestions">
    {suggestions.map((suggestion, i) => (
      <button
        key={i}
        onClick={() => sendMessage({ text: suggestion })}
      >
        {suggestion}
      </button>
    ))}
  </div>
)}
```

---

## User Persistence

**Frontend → Backend flow:**

1. **useUserId hook**: `src/hooks/useUserId.ts`
   - Returns `["default_user", () => {}]` by default
   - **Production**: Replace with your auth system
   - Designed to be easily pluggable

2. **AppSidebar**: Filters threads by `userId` when fetching:
   ```tsx
   fetchThreads(undefined, userId)
   ```

3. **ChatView**: Passes `user: userId` in `DefaultChatTransport` body:
   ```tsx
   body: {
     model: agentId,
     stream: true,
     user: userId,  // Required for user-scoped thread filtering
     ...(sessionId ? { session_id: sessionId } : {}),
   }
   ```

4. **Backend**: Filters threads by `user_id` from checkpoint metadata
   - See backend rules for details

5. **History Hydration**: Frontend hydrates history on mount from `/threads/{id}`
   - Backend returns normalized roles (`user`, `assistant`) and plain text content
   - Internal messages (tool, system) are filtered out

---

## Adapting to Different Frontend Structures

**If your project structure differs:**

1. **Routes Location:**
   - Template uses: TanStack Router file-based routing in `src/routes/`
   - Adapt: Update route definitions and imports
   - Ensure routing library supports SPA mode

2. **Components Location:**
   - Template uses: `src/components/`
   - Adapt: Update import paths (`@/components/...`)
   - Ensure path alias `@/` → `src/` is configured

3. **API Endpoints:**
   - Template uses: `/api/v1/agents/*` (proxied to backend)
   - Adapt: Update fetch URLs or proxy configuration
   - Ensure CORS is configured on backend

4. **Build Tool:**
   - Template uses: Vite with Bun
   - Adapt: Update `vite.config.ts` for your setup
   - Ensure proxy configuration matches your backend URL

5. **Styling:**
   - Template uses: Tailwind v4 with Shadcn/ui
   - Adapt: Update Tailwind config and component imports
   - Ensure CSS imports are correct

---

## Dependencies

**Required packages:**
```bash
bun add @ai-sdk/react ai streamdown
bun add @tanstack/react-router
bun add @radix-ui/react-*  # Shadcn/ui dependencies
bun add tailwindcss @tailwindcss/vite
bun add @phosphor-icons/react lucide-react
```

**AI Elements:**
```bash
bunx ai-elements@latest add message conversation reasoning
```

**TypeScript:**
- Strict mode enabled
- Path alias `@/` → `src/` configured
- Full typing required (avoid `any`)
